# Task 02.4: API Endpoints for F001

**Phase:** 02 - Backend - F001: Public Contract Aggregation
**Parent Plan:** [MVP Implementation Plan Overview](../00-mvp-implementation-plan-overview.md)
**Last Updated:** 2025-06-06

## 1. Objective

To develop FastAPI API endpoints that allow the frontend to query and retrieve aggregated public contract data stored in the local database, supporting basic filtering and pagination as required by F001.

## 2. Relevant Specifications

*   `/design/specifications/design-spec.md` (Sections: API Design Principles, Backend Architecture)
*   `/design/features/F001-Public-Contract-Aggregation-Display.md` (API endpoint requirements, filtering parameters)
*   Task 02.2: Data Models for F001 (for response schemas)
*   Task 01.2: Database Setup (for `get_db` dependency)

## 3. Key Implementation Steps

*   [ ] **Define Pydantic Schemas for API Responses:**
    *   Create `app/backend/src/fastapi_app/schemas/contract.py`.
    *   Define Pydantic models specifically for API responses (e.g., `ShipContractRead`). **Important:** These schemas are distinct from SQLAlchemy models. They define the API contract and should only include fields necessary for the client. Use `pydantic.BaseModel`.
    *   For fields derived from related models (e.g., `ship_name` from `EsiTypeCache`), ensure the schema reflects the final structure.
    *   Re-use or define a generic `Page[T]` Pydantic schema for paginated responses (e.g., in `app/backend/src/fastapi_app/schemas/common.py`).
    *   **AI Prompt:** "Generate Pydantic schemas for F001 API responses. \n1. `ShipContractRead` (in `schemas/contract.py`): This schema represents a single ship contract for display. It should include: `contract_id` (int), `ship_type_id` (int), `ship_name` (str), `price` (Optional[float]), `location_id` (Optional[int]), `location_name` (Optional[str]), `date_issued` (datetime), `title` (Optional[str]), `is_blueprint_copy` (Optional[bool]), `quantity` (int), `runs` (Optional[int]), `material_efficiency` (Optional[int]), `time_efficiency` (Optional[int]), `contains_additional_items` (bool). \n2. `Page[T]` (in `schemas/common.py`): A generic Pydantic schema for pagination, including `items: list[T]`, `total_items: int`, `total_pages: int`, `page: int`, `size: int`."
*   [ ] **Implement Ship Contract List Endpoint (e.g., `/api/v1/contracts/ships`):**
    *   Create `app/backend/src/fastapi_app/api/v1/endpoints/contracts.py`.
    *   Implement a GET endpoint to list contracts.
    *   **Query Parameters:** Support validated query parameters for filtering: `region_id: Optional[int] = Query(None)`, `ship_type_id: Optional[int] = Query(None)`, `is_blueprint_copy: Optional[bool] = Query(None)`. Also, pagination parameters: `page: int = Query(1, ge=1)`, `size: int = Query(20, ge=1, le=100)`.
    *   **Database Query:** Use SQLAlchemy to query the database. Filter `Contract` where `is_ship_contract == True`. 
        *   To construct `ShipContractRead`, you will need to join `Contract` with `ContractItem` (to get item details) and `EsiTypeCache` (to get `ship_name` from `type_id`).
        *   **Efficiency:** Thanks to full denormalization, the query is maximally efficient. It only needs to join `Contract` with `EsiTypeCache` on `Contract.ship_type_id` to get the `ship_name`. **No join with the `ContractItem` table is required**, which significantly reduces query complexity and improves performance.
    *   **Response:** Transform the SQLAlchemy model instances into `ShipContractRead` Pydantic schemas. Return data using the `Page[ShipContractRead]` schema.
    *   **Sorting:** Default sort by `date_issued` descending.
    *   **Error Handling:** Use standard FastAPI `HTTPException` for errors. If a `ship_name` for a `Contract.ship_type_id` is not found in `EsiTypeCache` (which indicates a data consistency issue the aggregation service should ideally prevent), log a clear warning on the backend detailing the missing `type_id` and return the contract with `ship_name` as `null` or a placeholder string (e.g., "Unknown Ship Type") rather than failing the entire request. This makes the API more resilient to minor data gaps and aids operators in diagnosing data issues.
    *   **Pre-mortem Note (Verbose Errors):** Ensure that error responses sent to the client in production do not contain overly verbose internal system details or stack traces. FastAPI's default `HTTPException` handling is generally good for this.
    *   **AI Prompt:** "Generate a FastAPI GET endpoint `/api/v1/contracts/ships` in `app/backend/src/fastapi_app/api/v1/endpoints/contracts.py`. \nThe endpoint should:
        1. Accept query parameters: `region_id: Optional[int]`, `ship_type_id: Optional[int]`, `is_blueprint_copy: Optional[bool]`, `page: int = Query(1, ge=1)`, `size: int = Query(20, ge=1, le=100)`.
        2. Depend on an async SQLAlchemy session (`db: AsyncSession = Depends(get_db)`).
        3. Construct a SQLAlchemy query for `Contract` objects where `is_ship_contract == True`.
        4. Apply filters based on provided query parameters.
        5. Implement pagination using `offset()` and `limit()`.
        6. To populate `ShipContractRead`:
           a. Join `Contract` with `EsiTypeCache` on `Contract.ship_type_id` to get the `ship_name`.
           b. Map all other fields for the `ShipContractRead` schema directly from the queried `Contract` model instance, as they have been denormalized.
        7. Transform query results into `ShipContractRead` Pydantic models.
        8. Return a `Page[ShipContractRead]` response, calculating `total_items` and `total_pages`.
        9. Sort results by `Contract.date_issued` descending."
*   [ ] **(Optional) Implement Single Contract Detail Endpoint (e.g., `/api/v1/contracts/{contract_id}`):**
    *   While F003 covers detailed views, a basic endpoint to fetch a single contract by ID might be useful here if F001 display implies clicking for more details not covered by the list view itself. For MVP, this might be deferred to F003 tasks.
    *   **Decision:** Defer to Phase 07 for F003.
*   [ ] **API Router Integration:**
    *   Create an `APIRouter` in `app/backend/src/fastapi_app/api/v1/endpoints/contracts.py`.
    *   Include this contracts router in a main v1 router in `app/backend/src/fastapi_app/api/v1/api.py`.
    *   Mount the main v1 router in `app/backend/src/fastapi_app/main.py` under the `/api/v1` prefix.
*   [ ] **Input Validation:**
    *   Rely on FastAPI's automatic validation for query parameters and Pydantic for request bodies (if any).

## 4. AI Implementation Guidance

*   Use FastAPI's `Depends` for database sessions (`get_db`).
*   Structure API endpoints logically using APIRouters.
*   Ensure Pydantic schemas accurately reflect the data to be exposed to the client.
*   Implement efficient database queries, especially for filtering and pagination.
    *   **Pre-mortem Note (Pagination Scalability):** Standard `OFFSET`-based pagination can become inefficient on very large datasets. For future scalability if this endpoint handles millions of records, consider migrating to keyset pagination (cursor-based pagination).
    *   **Pre-mortem Note (Query Complexity/DoS):** While basic validation is in place for pagination parameters, be mindful that complex combinations of other filter parameters could potentially lead to very slow queries. If performance issues arise, analyze slow query logs and consider adding limits to query complexity or more specific indexing.
*   Follow RESTful principles for API design.
*   **Future Consideration (Scalability/Security):** If API usage grows significantly or abuse is detected, consider implementing application-level API rate limiting (e.g., using a library like `slowapi`).
*   **Pre-mortem Note (Cross-Phase Friction):** Maintain very close communication with the frontend development team (Phase 3) regarding the exact structure of API request parameters (filters) and response schemas. Any discrepancies will cause integration delays. Regularly share OpenAPI schema definitions.

## 5. Definition of Done

*   Pydantic schemas for API responses are defined.
*   A GET endpoint to list contracts with basic filtering and pagination is implemented and functional.
*   The endpoint is integrated into the FastAPI application via an API router.
*   The API is tested locally (e.g., using Swagger UI or `curl`).
*   All new files and code changes are committed to version control.

## 6. Challenges & Resolutions

*   (Placeholder for any challenges encountered and their resolutions during this task.)

## 7. Cross-Cutting Concerns Review

This section documents how the five key cross-cutting concerns were addressed during the completion of this task. Refer to the primary specification documents for detailed guidance:
*   Security: `/design/specifications/security-spec.md`
*   Observability: `/design/specifications/observability-spec.md`
*   Testing: `/design/specifications/test-spec.md`
*   Accessibility: `/design/specifications/accessibility-spec.md`
*   Internationalization (i18n): `/design/specifications/i18n-spec.md`

### 7.1. Security
*   [x] **Secure Design:** Endpoints expose public, non-sensitive data. No authentication is required for these F001 endpoints.
*   [x] **Input Validation:** FastAPI handles basic type validation for query parameters. Pydantic models define response schemas. Add explicit validation for query parameter ranges (e.g., `page`, `size`) and allowed values for filters if applicable.
*   [ ] **Output Encoding:** FastAPI handles JSON response encoding, mitigating XSS for API responses.
*   [ ] **Authentication/Authorization:** N/A for public data endpoints in F001.
*   [ ] **Secrets Management:** N/A for this task.
*   [x] **Dependency Management:** FastAPI and Pydantic are managed by PDM.
*   **Notes:** Ensure pagination parameters (`size`) have a reasonable upper limit to prevent abuse.

### 7.2. Observability
*   [x] **Structured Logging:** Log incoming requests with query parameters.
*   [x] **Key Events Logged:** Log response status and duration for each API call.
*   [x] **Error Logging:** FastAPI's default exception handling will log errors. Ensure any custom error handling also logs appropriately.
*   [ ] **Correlation IDs:** If integrating with a broader tracing system, ensure correlation IDs are passed and logged.
*   [x] **Metrics:** Track request counts, error rates, and response latencies for these endpoints.
*   **Notes:** Remember the `logging.basicConfig()` setup in `main.py` is crucial for log visibility.

### 7.3. Testing
*   [ ] **Unit Tests:** Unit tests can cover any complex data transformation logic if it's separated into utility functions. Pydantic schema validation is implicitly tested.
*   [x] **Integration Tests:** Use FastAPI's `TestClient` to send requests to the endpoints.
    *   Mock the database dependency (`get_db`) to provide a test database session with pre-populated data.
    *   Verify successful responses (200 OK), including correct data structure (matching Pydantic schemas) and pagination logic.
    *   Test filtering logic by providing different query parameters and asserting the results.
    *   Test error conditions (e.g., invalid query parameters leading to 422 errors).
*   [ ] **Test Coverage:** Aim for good coverage of endpoint logic, including different filter combinations and pagination scenarios.
*   [x] **Test Data Management:** Use test fixtures to populate the test database with `Contract`, `ContractItem`, and `EsiTypeCache` records that cover various test cases.
*   **Notes:** `TestClient` is essential for testing FastAPI applications.

### 7.4. Accessibility (A11y)
*(Primarily for UI-related tasks, but consider CLI/API accessibility where relevant)*
*   [ ] **Semantic HTML/Structure:** (e.g., using appropriate tags for meaning)
*   [ ] **ARIA Attributes:** (e.g., for dynamic content or custom controls)
*   [ ] **Keyboard Navigability:** (e.g., all interactive elements reachable and operable via keyboard)
*   [ ] **Color Contrast:** (e.g., ensuring sufficient contrast for text and UI elements)
*   [ ] **Screen Reader Compatibility:** (e.g., testing with screen readers)
*   [ ] **Alternative Text for Images:** (e.g., providing descriptive alt text)
*   **Notes:** (Detail specific actions taken or rationale for no action, especially if not UI-related.)

### 7.5. Internationalization (I18n)
*(Primarily for UI-related tasks, but consider for any user-facing text including logs/error messages)*
*   [ ] **Text Abstraction:** (e.g., using translation keys instead of hardcoded strings)
*   [ ] **Locale-Specific Formatting:** (e.g., for dates, numbers, currencies)
*   [ ] **UI Layout Adaptability:** (e.g., for text expansion in different languages)
*   [ ] **Character Encoding:** (e.g., using UTF-8)
*   **Notes:** (Detail specific actions taken or rationale for no action, especially if not UI-related.)

---
<!-- This section should be placed before any final "Task Completion Checklist" or similar concluding remarks. -->
