# Task 07.1: API Endpoint for F003 (Detailed Contract View)

**Phase:** 07 - Backend - F003: Detailed Ship/Contract View
**Parent Plan:** [MVP Implementation Plan Overview](../00-mvp-implementation-plan-overview.md)
**Last Updated:** 2025-06-06

## 1. Objective

To develop a new backend API endpoint that provides detailed information for a single public contract, including all its items and relevant metadata, as required by Feature F003.

## 2. Relevant Specifications

*   `../../../design/features/F003-Detailed-Ship-Contract-View.md` (Defines the data requirements for the detailed view)
*   `../../../design/design-spec.md` (Sections: Backend Architecture, API Design Principles)
*   Task 02.2: Data Models for F001 (SQLAlchemy models for `Contract`, `ContractItem`)
*   `../../../design/api-design-guide.md` (If exists, for API consistency)

## 3. Key Implementation Steps

*   [ ] **Define API Endpoint Route:**
    *   Establish the route for fetching a single contract, e.g., `GET /api/v1/contracts/{contract_id}`.
*   [ ] **Create Pydantic Response Model(s):**
    *   Define Pydantic models for the detailed contract response. This should include:
        *   All fields from the `Contract` model.
        *   A list of associated `ContractItem` details.
        *   Potentially enriched data, like item names if only type IDs are stored, or location names.
    *   **AI Prompt:** "Generate Pydantic models for an API response representing a detailed contract. It should include fields like `contract_id`, `issuer_name`, `price`, `volume`, `type` (e.g., 'item_exchange'), `status`, `date_issued`, `date_expired`, `start_location_name`, `end_location_name` (if applicable), and a list of `items`. Each item in the list should have `type_id`, `type_name`, `quantity`, `is_included`."
*   [ ] **Implement FastAPI Endpoint Handler:**
    *   Create a new FastAPI path operation function that accepts `contract_id` as a path parameter.
    *   Implement logic to fetch the specified contract from the database using its ID.
    *   Use SQLAlchemy to eagerly load or efficiently query related `ContractItem` records.
    *   Handle the case where a contract with the given ID is not found (return HTTP 404).
    *   Populate and return the Pydantic response model.
    *   **AI Prompt:** "Show a FastAPI endpoint `GET /contracts/{contract_id}` that fetches a contract and its related items from a SQLAlchemy database. The contract model is `Contract` and items are `ContractItem` linked by `contract.items`. Return a 404 if not found. Use Pydantic models for the response."
*   [ ] **Database Query Optimization:**
    *   Ensure the database query to fetch the contract and its items is efficient. Use SQLAlchemy's relationship loading strategies (e.g., `selectinload` or `joinedload` for items).
*   [ ] **Update API Documentation:**
    *   Ensure the new endpoint is automatically documented in OpenAPI/Swagger. Add descriptions and examples if necessary.
*   [ ] **Integration Testing:**
    *   Write integration tests for the new endpoint:
        *   Test successful retrieval of a contract with its items.
        *   Test the 404 response for a non-existent contract ID.

## 4. AI Implementation Guidance

*   Use FastAPI's `Path` for path parameter validation.
*   Ensure proper error handling, especially for "not found" scenarios.
*   Structure Pydantic models clearly to represent the detailed view. If item details (like names from IDs) need to be resolved, decide if this happens at query time or in the service layer before serialization.

## 5. Definition of Done

*   A new API endpoint (e.g., `/api/v1/contracts/{contract_id}`) is implemented and functional.
*   Pydantic models for the detailed contract response are defined and used.
*   The endpoint fetches a contract and all its associated items from the database.
*   Appropriate HTTP 404 error is returned if the contract is not found.
*   Database queries are optimized for performance.
*   API documentation (OpenAPI/Swagger) is updated to include the new endpoint.
*   Integration tests for the new endpoint are written and passing.
*   All new/modified code is committed to version control.
