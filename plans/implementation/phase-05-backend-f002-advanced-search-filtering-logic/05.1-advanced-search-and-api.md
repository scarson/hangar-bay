# Task 05.1: Advanced Search, Filtering, and Sorting API

**Phase:** 05 - Backend - F002: Advanced Search & Filtering Logic
**Parent Plan:** [MVP Implementation Plan Overview](../00-mvp-implementation-plan-overview.md)
**Last Updated:** 2025-06-28

## 1. Objective

To enhance the backend API and database query capabilities to support the advanced search, multi-field filtering, and dynamic sorting requirements defined in Feature F002. This involves creating a flexible query service and updating the primary contracts API endpoint to accept a wide range of parameters, providing a powerful and performant search experience for the frontend.

## 2. Relevant Specifications

*   `/design/features/F002-Ship-Browsing-Advanced-Search-Filtering.md`
*   `/design/specifications/design-spec.md` (Backend Architecture, API Design)
*   Task 02.2: Data Models for F001 (Existing SQLAlchemy models)
*   Task 02.4: API Endpoints for F001 (Existing endpoint to be enhanced)

## 3. Key Implementation Steps

*   [ ] **Step 1: Define Comprehensive Pydantic Filter Model**
    *   In `fastapi_app/schemas/contract.py`, define a single Pydantic model (e.g., `ContractFilters`) to encapsulate all possible filter, pagination, and sorting parameters. This model will be injected into the API endpoint using `Depends`.
    *   Use FastAPI's `Query` for detailed validation (e.g., `Optional`, `gt`, `min_length`, list types) and to provide descriptions that will appear in the OpenAPI docs.
    *   **AI Prompt:** "Generate a Pydantic model `ContractFilters` to be used as FastAPI query parameters. It should include fields for text search (ship name, contract title), numeric ranges (price, collateral, runs, ME, TE), ID lists (region, system, station, ship type), booleans (is_bpc), pagination (page, size), and sorting (sort_by, sort_direction). Apply appropriate `Query` validations and descriptions for each field."

*   [ ] **Step 2: Create Contract Service for Query Logic**
    *   In accordance with the project architecture (`design/fastapi/00-fastapi-architecture-overview.md`), create a new module in the service layer: `fastapi_app/services/contract_service.py`.
    *   Implement a central function, e.g., `async def get_contracts(db: AsyncSession, filters: ContractFilters) -> PaginatedResponse`, that will contain all the database query logic.
    *   This separates the complex query construction from the API endpoint definition, improving testability and maintainability.

*   [ ] **Step 3: Implement Dynamic Filtering in Contract Service**
    *   Inside `services/contract_service.py`, build the SQLAlchemy query dynamically based on the provided `filters`.
    *   The query should join `Contract`, `EsiTypeCache` (for ship name/group), and potentially other tables as needed.
    *   Apply filter conditions only if they are present in the `filters` object.
    *   Use `ilike` for case-insensitive text searches.
    *   Handle numeric range filters (e.g., `price >= min_price`).
    *   Handle `IN` clauses for list-based filters (e.g., `region_id IN (...)`).

*   [ ] **Step 4: Implement Dynamic Sorting in Contract Service**
    *   Extend the query-building logic in `services/contract_service.py` to handle sorting.
    *   Create a mapping of allowed `sort_by` string values (from the API) to the actual SQLAlchemy model columns (e.g., `{'price': Contract.price, 'date_issued': Contract.date_issued}`). This prevents arbitrary column sorting.
    *   Apply the `order_by` clause to the query based on the `sort_by` and `sort_direction` filter parameters.

*   [ ] **Step 5: Update API Endpoint to Use Contract Service**
    *   Refactor the `/api/v1/contracts/ships` endpoint in `fastapi_app/api/v1/endpoints/contracts.py`.
    *   The endpoint's implementation should now be very simple: it takes the `ContractFilters` dependency and calls the `services.contract_service.get_contracts` function, returning its result.

*   [ ] **Step 6: Performance Review and Indexing**
    *   Based on the full set of filterable and sortable fields, review the `Contract` and `EsiTypeCache` models.
    *   Add or update database indexes as needed to ensure query performance. Pay special attention to columns used in `WHERE` clauses, `JOIN`s, and `ORDER BY` clauses.
    *   Consider creating composite indexes for frequently combined filters.
    *   **AI Prompt:** "Given the filterable fields in the `ContractFilters` model, what database indexes should be added to the `Contract` and `EsiTypeCache` tables to optimize query performance for advanced filtering and sorting?"

*   [ ] **Step 7: Update Integration Tests**
    *   Update the `TestClient` integration tests for the `/api/v1/contracts/ships` endpoint.
    *   Add new test cases that verify the functionality of various advanced filter combinations and sorting options.

## 4. AI Implementation Guidance

*   **Separation of Concerns:** Keep the API endpoint file (`endpoints/contracts.py`) clean and focused on routing and request/response handling. All the complex business logic for building database queries should reside in the `services/contract_service.py` service.
*   **Safe Sorting:** Always validate the `sort_by` parameter against a pre-defined allowlist of columns to prevent SQL injection or unexpected behavior.
*   **Query Efficiency:** Use `selectinload` for relationships where appropriate to avoid the N+1 query problem, although for this paginated list view, direct joins are likely more efficient.

## 5. Definition of Done

*   A new `services/contract_service.py` module exists and contains the advanced query logic.
*   The `ContractFilters` Pydantic model is defined and used by the API.
*   The `/api/v1/contracts/ships` endpoint is updated to accept all advanced filter, sort, and pagination parameters, and it uses the new contract service.
*   Necessary database indexes have been added via an Alembic migration.
*   Integration tests are updated to cover new filtering and sorting functionality.
*   The old planning files (`05.1-advanced-filtering-logic.md` and `05.2-api-endpoints-f002-update.md`) are deleted.
*   All changes are committed to version control.

## 6. Challenges & Resolutions

*   (Placeholder for any challenges encountered and their resolutions during this task.)

## 7. Cross-Cutting Concerns Review

This section documents how the five key cross-cutting concerns were addressed during the completion of this task. Refer to the primary specification documents for detailed guidance:
*   Security: `/design/specifications/security-spec.md`
*   Observability: `/design/specifications/observability-spec.md`
*   Testing: `/design/specifications/test-spec.md`
*   Accessibility: `/design/specifications/accessibility-spec.md`
*   Internationalization (i18n): `/design/specifications/i18n-spec.md`

### 7.1. Security
*   [ ] **Secure Design:** The primary security design consideration is preventing SQL injection through the dynamic sorting parameter. This will be mitigated by mapping API-facing sort keys to specific, safe SQLAlchemy column objects.
*   [ ] **Input Validation:** All incoming filter, sort, and pagination parameters will be strictly validated by the `ContractFilters` Pydantic model, using FastAPI's `Query` for constraints on types, ranges, and lengths.
*   [x] **Output Encoding:** N/A. This API endpoint returns JSON data, not HTML. The responsibility for preventing XSS by properly encoding output lies with the frontend client that consumes this data.
*   [ ] **Authentication/Authorization:** This is a public, unauthenticated endpoint. No specific authentication or authorization checks are required for this task.
*   [x] **Secrets Management:** N/A. This task does not involve handling any secrets, API keys, or credentials.
*   [ ] **Dependency Management:** All dependencies are managed via `pdm` and pinned in `pyproject.toml`. No new dependencies are anticipated for this task, but if any were added, they would be subject to review.
*   **Notes:** The core security focus is robust input validation via Pydantic and safe handling of the dynamic `sort_by` parameter to prevent misuse.

### 7.2. Observability
*   [ ] **Structured Logging:** Logging will be implemented to capture the key filter parameters used in each API call. This will help diagnose performance issues or unexpected results from complex queries.
*   [ ] **Key Events Logged:** The primary event to log is the execution of a search query, including the filter criteria.
*   [ ] **Error Logging:** Any database errors or validation errors that occur during query construction or execution will be logged with sufficient detail for debugging.
*   [x] **Correlation IDs:** N/A. While important for a distributed system, this is a single monolithic backend service, so request tracing across services is not applicable for this task.
*   [ ] **Metrics:** We will consider adding a metric for query execution time to monitor the performance of the dynamic query generation.
*   **Notes:** The main goal for observability in this task is to gain insight into how the advanced filtering is being used and how it performs.

### 7.3. Testing
*   [ ] **Unit Tests:** Unit tests will be created for the `crud.contract` service layer to test the query-building logic in isolation from the database and API.
*   [ ] **Integration Tests:** The existing `TestClient` integration tests for the contracts endpoint will be expanded significantly to cover a wide variety of filter, sort, and pagination combinations to ensure the end-to-end functionality is correct.
*   [ ] **Test Coverage:** We will aim to achieve high test coverage for the new `crud.contract` module.
*   [ ] **Test Data Management:** Tests will rely on a pre-populated test database, with specific records designed to validate different filtering scenarios (e.g., contracts that should match a price range, contracts that shouldn't, etc.).
*   **Notes:** A robust set of integration tests is critical for this task to ensure the complex filtering logic is behaving as expected from the API consumer's perspective.

### 7.4. Accessibility (A11y)
*(Primarily for UI-related tasks, but consider CLI/API accessibility where relevant)*
*   [x] **Semantic HTML/Structure:** N/A. This is a backend API task.
*   [x] **ARIA Attributes:** N/A. This is a backend API task.
*   [x] **Keyboard Navigability:** N/A. This is a backend API task.
*   [x] **Color Contrast:** N/A. This is a backend API task.
*   [x] **Screen Reader Compatibility:** N/A. This is a backend API task.
*   [x] **Alternative Text for Images:** N/A. This is a backend API task.
*   **Notes:** N/A. This is a backend-only task that produces JSON data and has no user interface. Accessibility concerns will be handled by the frontend client.

### 7.5. Internationalization (I18n)
*(Primarily for UI-related tasks, but consider for any user-facing text including logs/error messages)*
*   [x] **Text Abstraction:** N/A. The API returns raw data. Any user-facing strings (like ship names) come directly from the ESI data source and are not localized at the backend level.
*   [x] **Locale-Specific Formatting:** N/A. The API returns data in standard formats (e.g., ISO 8601 for dates, standard float/int for numbers). It is the client's responsibility to format this data for the user's locale.
*   [x] **UI Layout Adaptability:** N/A. This is a backend API task.
*   [ ] **Character Encoding:** The service will operate assuming UTF-8 encoding for all text data, which is standard for FastAPI and modern web applications.
*   **Notes:** N/A. This is a backend-only task. Internationalization is not a concern for the data layer in this context.
