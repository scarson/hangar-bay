# Task 05.1: Advanced Filtering Logic & Query Enhancements

**Phase:** 05 - Backend - F002: Advanced Search & Filtering Logic
**Parent Plan:** [MVP Implementation Plan Overview](../00-mvp-implementation-plan-overview.md)
**Last Updated:** 2025-06-06

## 1. Objective

To enhance the backend's database query capabilities to support advanced search and filtering requirements as defined in Feature F002. This includes implementing logic for more complex filter combinations, text-based searches, and range queries.

## 2. Relevant Specifications

*   `../../../design/features/F002-Ship-Browsing-Advanced-Search-Filtering.md` (Defines advanced filtering criteria)
*   `../../../design/design-spec.md` (Sections: Backend Architecture, Database Design)
*   Task 02.2: Data Models for F001 (Existing SQLAlchemy models to be queried)
*   Task 02.4: API Endpoints for F001 (Existing query logic to be extended)

## 3. Key Implementation Steps

*   [ ] **Analyze F002 Advanced Filter Requirements:**
    *   Thoroughly review F002 for all specified advanced filters (e.g., item name/type text search, price ranges, volume ranges, specific ship types/attributes, solar system/constellation).
*   [ ] **Design SQLAlchemy Query Enhancements:**
    *   Plan how to translate F002 filter requirements into SQLAlchemy query conditions.
    *   Consider using `ILIKE` or full-text search capabilities for item name/type searches.
    *   Implement logic for range filters (e.g., `price_min`, `price_max`).
    *   **AI Prompt:** "Show an example SQLAlchemy query for a `ContractItem` model that filters by `name ILIKE '%search_term%'` and a price between `min_price` and `max_price` on a related `Contract` model."
*   [ ] **Implement Dynamic Query Building:**
    *   Develop a strategy to dynamically build SQLAlchemy queries based on the presence of various optional filter parameters.
    *   Ensure that only provided filters are applied to the query.
*   [ ] **Update/Extend Pydantic Models (for internal use if needed):**
    *   If complex filter objects are passed internally within the backend, update or create Pydantic models for them. (API-facing models are handled in Task 05.2).
*   [ ] **Performance Considerations:**
    *   Analyze potential performance impacts of new filter combinations.
    *   Identify necessary database indexes for new query patterns (refer to Task 02.2 for existing indexes).
    *   **AI Prompt:** "What database indexes should be considered for a table with columns `item_name` (text), `price` (numeric), and `volume` (numeric) if queries will filter by `item_name ILIKE '%term%'`, `price BETWEEN x AND y`, and `volume > z`?"
*   [ ] **Unit Testing:**
    *   Write unit tests for the new filtering logic to ensure correctness with various filter combinations.

## 4. AI Implementation Guidance

*   Leverage SQLAlchemy's flexible query construction capabilities.
*   For text search, evaluate PostgreSQL's full-text search features (e.g., `tsvector`, `tsquery`) if simple `ILIKE` is insufficient for performance or relevance.
*   Ensure that database sessions are managed correctly, especially with complex queries.

## 5. Definition of Done

*   Backend logic can construct and execute database queries incorporating advanced filters from F002.
*   Dynamic query building handles optional filter parameters correctly.
*   Performance implications are considered, and potential indexing needs are identified.
*   Internal Pydantic models (if any) for filter parameters are updated.
*   Unit tests for the advanced filtering logic are implemented and passing.
*   All new/modified code is committed to version control.
